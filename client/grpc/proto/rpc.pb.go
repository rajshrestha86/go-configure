// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rpc.proto

package rpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Slave struct {
	Username             string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Host                 string   `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Id                   string   `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Slave) Reset()         { *m = Slave{} }
func (m *Slave) String() string { return proto.CompactTextString(m) }
func (*Slave) ProtoMessage()    {}
func (*Slave) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{0}
}

func (m *Slave) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Slave.Unmarshal(m, b)
}
func (m *Slave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Slave.Marshal(b, m, deterministic)
}
func (m *Slave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slave.Merge(m, src)
}
func (m *Slave) XXX_Size() int {
	return xxx_messageInfo_Slave.Size(m)
}
func (m *Slave) XXX_DiscardUnknown() {
	xxx_messageInfo_Slave.DiscardUnknown(m)
}

var xxx_messageInfo_Slave proto.InternalMessageInfo

func (m *Slave) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Slave) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Slave) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Slave) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Status struct {
	Status               bool     `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{1}
}

func (m *Status) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Status.Unmarshal(m, b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Status.Marshal(b, m, deterministic)
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return xxx_messageInfo_Status.Size(m)
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type File struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{2}
}

func (m *File) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_File.Unmarshal(m, b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_File.Marshal(b, m, deterministic)
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return xxx_messageInfo_File.Size(m)
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *File) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type RunConfiguration struct {
	SlaveID              string   `protobuf:"bytes,1,opt,name=slaveID,proto3" json:"slaveID,omitempty"`
	ConfigName           string   `protobuf:"bytes,2,opt,name=configName,proto3" json:"configName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunConfiguration) Reset()         { *m = RunConfiguration{} }
func (m *RunConfiguration) String() string { return proto.CompactTextString(m) }
func (*RunConfiguration) ProtoMessage()    {}
func (*RunConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{3}
}

func (m *RunConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RunConfiguration.Unmarshal(m, b)
}
func (m *RunConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RunConfiguration.Marshal(b, m, deterministic)
}
func (m *RunConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunConfiguration.Merge(m, src)
}
func (m *RunConfiguration) XXX_Size() int {
	return xxx_messageInfo_RunConfiguration.Size(m)
}
func (m *RunConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_RunConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_RunConfiguration proto.InternalMessageInfo

func (m *RunConfiguration) GetSlaveID() string {
	if m != nil {
		return m.SlaveID
	}
	return ""
}

func (m *RunConfiguration) GetConfigName() string {
	if m != nil {
		return m.ConfigName
	}
	return ""
}

type Job struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{4}
}

func (m *Job) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Job.Unmarshal(m, b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Job.Marshal(b, m, deterministic)
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return xxx_messageInfo_Job.Size(m)
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{5}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Message struct {
	Text                 string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{6}
}

func (m *Message) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Message.Unmarshal(m, b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Message.Marshal(b, m, deterministic)
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return xxx_messageInfo_Message.Size(m)
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type OutputId struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutputId) Reset()         { *m = OutputId{} }
func (m *OutputId) String() string { return proto.CompactTextString(m) }
func (*OutputId) ProtoMessage()    {}
func (*OutputId) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{7}
}

func (m *OutputId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutputId.Unmarshal(m, b)
}
func (m *OutputId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutputId.Marshal(b, m, deterministic)
}
func (m *OutputId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputId.Merge(m, src)
}
func (m *OutputId) XXX_Size() int {
	return xxx_messageInfo_OutputId.Size(m)
}
func (m *OutputId) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputId.DiscardUnknown(m)
}

var xxx_messageInfo_OutputId proto.InternalMessageInfo

func (m *OutputId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func init() {
	proto.RegisterType((*Slave)(nil), "Slave")
	proto.RegisterType((*Status)(nil), "Status")
	proto.RegisterType((*File)(nil), "File")
	proto.RegisterType((*RunConfiguration)(nil), "RunConfiguration")
	proto.RegisterType((*Job)(nil), "Job")
	proto.RegisterType((*Empty)(nil), "Empty")
	proto.RegisterType((*Message)(nil), "Message")
	proto.RegisterType((*OutputId)(nil), "OutputId")
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor_77a6da22d6a3feb1) }

var fileDescriptor_77a6da22d6a3feb1 = []byte{
	// 540 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0x6d, 0x6f, 0xda, 0x30,
	0x10, 0xc7, 0x95, 0xf2, 0x7c, 0x43, 0x15, 0xf3, 0xc4, 0x84, 0x98, 0xc6, 0xda, 0x48, 0x9d, 0x98,
	0x26, 0x59, 0xa8, 0xdb, 0x17, 0x40, 0x74, 0x30, 0x18, 0x5d, 0xa5, 0x50, 0x6d, 0xaf, 0x0d, 0x31,
	0x60, 0x29, 0x89, 0xa3, 0xf8, 0x02, 0xeb, 0x57, 0xdf, 0xab, 0xc9, 0xce, 0x03, 0xc9, 0x56, 0xf6,
	0x2a, 0xe7, 0xf3, 0xef, 0xfe, 0xf7, 0xf7, 0xd9, 0x00, 0xad, 0x28, 0xdc, 0xd0, 0x30, 0x92, 0x28,
	0xed, 0x0d, 0xd4, 0x56, 0x1e, 0x3b, 0x70, 0xd2, 0x87, 0x66, 0xac, 0x78, 0x14, 0x30, 0x9f, 0xf7,
	0xac, 0x2b, 0x6b, 0xd8, 0x72, 0xf2, 0x35, 0x21, 0x50, 0xdd, 0x4b, 0x85, 0xbd, 0x0b, 0x93, 0x37,
	0xb1, 0xe6, 0x43, 0xa6, 0xd4, 0x51, 0x46, 0x6e, 0xaf, 0x92, 0xf0, 0xd9, 0x9a, 0x5c, 0xc2, 0x85,
	0x70, 0x7b, 0x55, 0x93, 0xbd, 0x10, 0xae, 0x7d, 0x05, 0xf5, 0x15, 0x32, 0x8c, 0x15, 0x79, 0x0d,
	0x75, 0x65, 0x22, 0xd3, 0xa3, 0xe9, 0xa4, 0x2b, 0x9b, 0x42, 0x75, 0x2a, 0x3c, 0xd3, 0xc9, 0x65,
	0xc8, 0xcc, 0x6e, 0xdb, 0x31, 0xb1, 0xce, 0x19, 0x57, 0x69, 0x77, 0x1d, 0xdb, 0x4b, 0xe8, 0x38,
	0x71, 0x30, 0x91, 0xc1, 0x56, 0xec, 0xe2, 0x88, 0xa1, 0x90, 0x01, 0xe9, 0x41, 0x43, 0xe9, 0xa3,
	0xcc, 0xef, 0xd2, 0x03, 0x64, 0x4b, 0x32, 0x00, 0xd8, 0x18, 0xf4, 0xfb, 0x49, 0xa7, 0x90, 0xb1,
	0xbb, 0x50, 0x59, 0xc8, 0x75, 0x6a, 0x5b, 0xd7, 0xd6, 0x8c, 0xed, 0x06, 0xd4, 0xbe, 0xf8, 0x21,
	0x3e, 0xd9, 0x6f, 0xa1, 0x71, 0xcf, 0x95, 0x62, 0x3b, 0x63, 0x10, 0xf9, 0x2f, 0x4c, 0x3b, 0x98,
	0xd8, 0xee, 0x43, 0xf3, 0x21, 0xc6, 0x30, 0xc6, 0xb9, 0x5b, 0xd0, 0x30, 0x47, 0xbf, 0xfd, 0x5d,
	0x83, 0xca, 0x64, 0x39, 0x27, 0x6f, 0xa0, 0x39, 0x76, 0xdd, 0x64, 0xd4, 0x75, 0x6a, 0xbe, 0xfd,
	0x06, 0x4d, 0xa7, 0x32, 0x80, 0x17, 0x77, 0xdc, 0xe3, 0xc8, 0xcf, 0xee, 0xc3, 0x52, 0x28, 0x34,
	0x59, 0x45, 0xea, 0xd4, 0xb8, 0xea, 0xa7, 0xd8, 0xc8, 0x22, 0xef, 0xa0, 0x5d, 0xa8, 0x3f, 0x11,
	0xb9, 0xc0, 0x7b, 0x20, 0x8f, 0x11, 0x0b, 0xd4, 0x96, 0x47, 0xc9, 0xcc, 0xcc, 0xb0, 0x6b, 0x54,
	0x7f, 0x72, 0x6a, 0x68, 0x91, 0x6b, 0xb8, 0x74, 0x38, 0x73, 0x0b, 0x4c, 0x26, 0x95, 0xb0, 0x23,
	0x8b, 0x0c, 0x81, 0x68, 0x2f, 0xa5, 0xd1, 0x9f, 0x3a, 0x36, 0x69, 0x3a, 0xa8, 0x91, 0x45, 0x6e,
	0xa0, 0xe3, 0x70, 0x5f, 0x1e, 0x78, 0x41, 0x2e, 0xdf, 0x3f, 0x79, 0xbb, 0x85, 0xee, 0x0a, 0x59,
	0x84, 0x5a, 0x95, 0x07, 0x22, 0xd8, 0x4d, 0x23, 0xe9, 0x4f, 0xd4, 0x81, 0xbc, 0xa4, 0x7f, 0x5f,
	0x71, 0xbf, 0x4a, 0x17, 0x72, 0x3d, 0xb4, 0x08, 0x85, 0x57, 0xe5, 0x9a, 0x64, 0x70, 0xe7, 0x2a,
	0xb4, 0xe9, 0x1f, 0x82, 0x1f, 0xc7, 0x9e, 0xe7, 0xc4, 0x81, 0xe6, 0x17, 0x72, 0xfd, 0xbc, 0xe9,
	0x6b, 0xe8, 0xac, 0x50, 0x86, 0xb9, 0xb0, 0xae, 0x36, 0x1a, 0x27, 0xc3, 0x37, 0x40, 0x34, 0x72,
	0x46, 0x2c, 0xc7, 0x3e, 0x42, 0x57, 0xab, 0x24, 0x2f, 0xe3, 0x1b, 0x7f, 0x52, 0x53, 0x19, 0x7d,
	0xd5, 0xbf, 0x9c, 0xec, 0x7a, 0xcb, 0xb3, 0x6a, 0xcf, 0x38, 0x3a, 0xec, 0x98, 0xe0, 0xa4, 0x45,
	0xb3, 0x17, 0x55, 0xc2, 0x3e, 0x40, 0x67, 0xc6, 0xf1, 0x9e, 0xe1, 0x66, 0xcf, 0xdd, 0xff, 0xa3,
	0x76, 0xf6, 0x26, 0xfe, 0xc5, 0x72, 0x8b, 0x9f, 0x61, 0x50, 0x64, 0x7e, 0x0a, 0xdc, 0xcf, 0xc4,
	0x81, 0x07, 0x8f, 0xc2, 0xe7, 0x0a, 0x99, 0x1f, 0x3e, 0x5b, 0x35, 0x84, 0x6e, 0x52, 0x35, 0xf6,
	0xbc, 0x64, 0xf7, 0x61, 0x5b, 0x3a, 0x58, 0x46, 0xae, 0xeb, 0xe6, 0x3f, 0xe6, 0xd3, 0x9f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xda, 0xb8, 0x49, 0xc0, 0x70, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CLIClient is the client API for CLI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CLIClient interface {
	//    Slave Management
	AddSlave(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error)
	DeleteSlave(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error)
	ListSlaves(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ListSlavesClient, error)
	DeleteSlaves(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	//    Config Management.
	TransferConfigFile(ctx context.Context, opts ...grpc.CallOption) (CLI_TransferConfigFileClient, error)
	ReadConfigFile(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ReadConfigFileClient, error)
	ListConfigurations(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ListConfigurationsClient, error)
	RemoveConfigFile(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Status, error)
	//    Listening Management.
	StartListeningFromCsv(ctx context.Context, opts ...grpc.CallOption) (CLI_StartListeningFromCsvClient, error)
	StartListeningSlave(ctx context.Context, in *RunConfiguration, opts ...grpc.CallOption) (*Job, error)
	ViewAllRunningJobs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ViewAllRunningJobsClient, error)
	StopListeningJob(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Status, error)
	StopAllRunningJobs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	// Output
	ListOutputKeysForHost(ctx context.Context, in *Slave, opts ...grpc.CallOption) (CLI_ListOutputKeysForHostClient, error)
	GetRawOutput(ctx context.Context, in *OutputId, opts ...grpc.CallOption) (CLI_GetRawOutputClient, error)
	GetMatchedOutput(ctx context.Context, in *OutputId, opts ...grpc.CallOption) (CLI_GetMatchedOutputClient, error)
	DeleteOutput(ctx context.Context, in *OutputId, opts ...grpc.CallOption) (*Status, error)
	DeleteOutputWithGivenTimestamp(ctx context.Context, in *OutputId, opts ...grpc.CallOption) (*Status, error)
	DeleteAllOutputOfHost(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error)
}

type cLIClient struct {
	cc *grpc.ClientConn
}

func NewCLIClient(cc *grpc.ClientConn) CLIClient {
	return &cLIClient{cc}
}

func (c *cLIClient) AddSlave(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/AddSlave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) DeleteSlave(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/DeleteSlave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) ListSlaves(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ListSlavesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[0], "/CLI/ListSlaves", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLIListSlavesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CLI_ListSlavesClient interface {
	Recv() (*Slave, error)
	grpc.ClientStream
}

type cLIListSlavesClient struct {
	grpc.ClientStream
}

func (x *cLIListSlavesClient) Recv() (*Slave, error) {
	m := new(Slave)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) DeleteSlaves(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/DeleteSlaves", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) TransferConfigFile(ctx context.Context, opts ...grpc.CallOption) (CLI_TransferConfigFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[1], "/CLI/TransferConfigFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLITransferConfigFileClient{stream}
	return x, nil
}

type CLI_TransferConfigFileClient interface {
	Send(*File) error
	CloseAndRecv() (*Status, error)
	grpc.ClientStream
}

type cLITransferConfigFileClient struct {
	grpc.ClientStream
}

func (x *cLITransferConfigFileClient) Send(m *File) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cLITransferConfigFileClient) CloseAndRecv() (*Status, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Status)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) ReadConfigFile(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ReadConfigFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[2], "/CLI/ReadConfigFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLIReadConfigFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CLI_ReadConfigFileClient interface {
	Recv() (*File, error)
	grpc.ClientStream
}

type cLIReadConfigFileClient struct {
	grpc.ClientStream
}

func (x *cLIReadConfigFileClient) Recv() (*File, error) {
	m := new(File)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) ListConfigurations(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ListConfigurationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[3], "/CLI/ListConfigurations", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLIListConfigurationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CLI_ListConfigurationsClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type cLIListConfigurationsClient struct {
	grpc.ClientStream
}

func (x *cLIListConfigurationsClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) RemoveConfigFile(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/RemoveConfigFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) StartListeningFromCsv(ctx context.Context, opts ...grpc.CallOption) (CLI_StartListeningFromCsvClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[4], "/CLI/StartListeningFromCsv", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLIStartListeningFromCsvClient{stream}
	return x, nil
}

type CLI_StartListeningFromCsvClient interface {
	Send(*RunConfiguration) error
	CloseAndRecv() (*Job, error)
	grpc.ClientStream
}

type cLIStartListeningFromCsvClient struct {
	grpc.ClientStream
}

func (x *cLIStartListeningFromCsvClient) Send(m *RunConfiguration) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cLIStartListeningFromCsvClient) CloseAndRecv() (*Job, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Job)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) StartListeningSlave(ctx context.Context, in *RunConfiguration, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := c.cc.Invoke(ctx, "/CLI/StartListeningSlave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) ViewAllRunningJobs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ViewAllRunningJobsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[5], "/CLI/ViewAllRunningJobs", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLIViewAllRunningJobsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CLI_ViewAllRunningJobsClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type cLIViewAllRunningJobsClient struct {
	grpc.ClientStream
}

func (x *cLIViewAllRunningJobsClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) StopListeningJob(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/StopListeningJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) StopAllRunningJobs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/StopAllRunningJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) ListOutputKeysForHost(ctx context.Context, in *Slave, opts ...grpc.CallOption) (CLI_ListOutputKeysForHostClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[6], "/CLI/ListOutputKeysForHost", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLIListOutputKeysForHostClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CLI_ListOutputKeysForHostClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type cLIListOutputKeysForHostClient struct {
	grpc.ClientStream
}

func (x *cLIListOutputKeysForHostClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) GetRawOutput(ctx context.Context, in *OutputId, opts ...grpc.CallOption) (CLI_GetRawOutputClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[7], "/CLI/GetRawOutput", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLIGetRawOutputClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CLI_GetRawOutputClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type cLIGetRawOutputClient struct {
	grpc.ClientStream
}

func (x *cLIGetRawOutputClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) GetMatchedOutput(ctx context.Context, in *OutputId, opts ...grpc.CallOption) (CLI_GetMatchedOutputClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[8], "/CLI/GetMatchedOutput", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLIGetMatchedOutputClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CLI_GetMatchedOutputClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type cLIGetMatchedOutputClient struct {
	grpc.ClientStream
}

func (x *cLIGetMatchedOutputClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) DeleteOutput(ctx context.Context, in *OutputId, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/DeleteOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) DeleteOutputWithGivenTimestamp(ctx context.Context, in *OutputId, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/DeleteOutputWithGivenTimestamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) DeleteAllOutputOfHost(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/DeleteAllOutputOfHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CLIServer is the server API for CLI service.
type CLIServer interface {
	//    Slave Management
	AddSlave(context.Context, *Slave) (*Status, error)
	DeleteSlave(context.Context, *Slave) (*Status, error)
	ListSlaves(*Empty, CLI_ListSlavesServer) error
	DeleteSlaves(context.Context, *Empty) (*Status, error)
	//    Config Management.
	TransferConfigFile(CLI_TransferConfigFileServer) error
	ReadConfigFile(*Empty, CLI_ReadConfigFileServer) error
	ListConfigurations(*Empty, CLI_ListConfigurationsServer) error
	RemoveConfigFile(context.Context, *Message) (*Status, error)
	//    Listening Management.
	StartListeningFromCsv(CLI_StartListeningFromCsvServer) error
	StartListeningSlave(context.Context, *RunConfiguration) (*Job, error)
	ViewAllRunningJobs(*Empty, CLI_ViewAllRunningJobsServer) error
	StopListeningJob(context.Context, *Job) (*Status, error)
	StopAllRunningJobs(context.Context, *Empty) (*Status, error)
	// Output
	ListOutputKeysForHost(*Slave, CLI_ListOutputKeysForHostServer) error
	GetRawOutput(*OutputId, CLI_GetRawOutputServer) error
	GetMatchedOutput(*OutputId, CLI_GetMatchedOutputServer) error
	DeleteOutput(context.Context, *OutputId) (*Status, error)
	DeleteOutputWithGivenTimestamp(context.Context, *OutputId) (*Status, error)
	DeleteAllOutputOfHost(context.Context, *Slave) (*Status, error)
}

// UnimplementedCLIServer can be embedded to have forward compatible implementations.
type UnimplementedCLIServer struct {
}

func (*UnimplementedCLIServer) AddSlave(ctx context.Context, req *Slave) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSlave not implemented")
}
func (*UnimplementedCLIServer) DeleteSlave(ctx context.Context, req *Slave) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSlave not implemented")
}
func (*UnimplementedCLIServer) ListSlaves(req *Empty, srv CLI_ListSlavesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListSlaves not implemented")
}
func (*UnimplementedCLIServer) DeleteSlaves(ctx context.Context, req *Empty) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSlaves not implemented")
}
func (*UnimplementedCLIServer) TransferConfigFile(srv CLI_TransferConfigFileServer) error {
	return status.Errorf(codes.Unimplemented, "method TransferConfigFile not implemented")
}
func (*UnimplementedCLIServer) ReadConfigFile(req *Empty, srv CLI_ReadConfigFileServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadConfigFile not implemented")
}
func (*UnimplementedCLIServer) ListConfigurations(req *Empty, srv CLI_ListConfigurationsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListConfigurations not implemented")
}
func (*UnimplementedCLIServer) RemoveConfigFile(ctx context.Context, req *Message) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveConfigFile not implemented")
}
func (*UnimplementedCLIServer) StartListeningFromCsv(srv CLI_StartListeningFromCsvServer) error {
	return status.Errorf(codes.Unimplemented, "method StartListeningFromCsv not implemented")
}
func (*UnimplementedCLIServer) StartListeningSlave(ctx context.Context, req *RunConfiguration) (*Job, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartListeningSlave not implemented")
}
func (*UnimplementedCLIServer) ViewAllRunningJobs(req *Empty, srv CLI_ViewAllRunningJobsServer) error {
	return status.Errorf(codes.Unimplemented, "method ViewAllRunningJobs not implemented")
}
func (*UnimplementedCLIServer) StopListeningJob(ctx context.Context, req *Job) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopListeningJob not implemented")
}
func (*UnimplementedCLIServer) StopAllRunningJobs(ctx context.Context, req *Empty) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopAllRunningJobs not implemented")
}
func (*UnimplementedCLIServer) ListOutputKeysForHost(req *Slave, srv CLI_ListOutputKeysForHostServer) error {
	return status.Errorf(codes.Unimplemented, "method ListOutputKeysForHost not implemented")
}
func (*UnimplementedCLIServer) GetRawOutput(req *OutputId, srv CLI_GetRawOutputServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRawOutput not implemented")
}
func (*UnimplementedCLIServer) GetMatchedOutput(req *OutputId, srv CLI_GetMatchedOutputServer) error {
	return status.Errorf(codes.Unimplemented, "method GetMatchedOutput not implemented")
}
func (*UnimplementedCLIServer) DeleteOutput(ctx context.Context, req *OutputId) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOutput not implemented")
}
func (*UnimplementedCLIServer) DeleteOutputWithGivenTimestamp(ctx context.Context, req *OutputId) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOutputWithGivenTimestamp not implemented")
}
func (*UnimplementedCLIServer) DeleteAllOutputOfHost(ctx context.Context, req *Slave) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllOutputOfHost not implemented")
}

func RegisterCLIServer(s *grpc.Server, srv CLIServer) {
	s.RegisterService(&_CLI_serviceDesc, srv)
}

func _CLI_AddSlave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Slave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).AddSlave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/AddSlave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).AddSlave(ctx, req.(*Slave))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_DeleteSlave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Slave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).DeleteSlave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/DeleteSlave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).DeleteSlave(ctx, req.(*Slave))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_ListSlaves_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CLIServer).ListSlaves(m, &cLIListSlavesServer{stream})
}

type CLI_ListSlavesServer interface {
	Send(*Slave) error
	grpc.ServerStream
}

type cLIListSlavesServer struct {
	grpc.ServerStream
}

func (x *cLIListSlavesServer) Send(m *Slave) error {
	return x.ServerStream.SendMsg(m)
}

func _CLI_DeleteSlaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).DeleteSlaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/DeleteSlaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).DeleteSlaves(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_TransferConfigFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CLIServer).TransferConfigFile(&cLITransferConfigFileServer{stream})
}

type CLI_TransferConfigFileServer interface {
	SendAndClose(*Status) error
	Recv() (*File, error)
	grpc.ServerStream
}

type cLITransferConfigFileServer struct {
	grpc.ServerStream
}

func (x *cLITransferConfigFileServer) SendAndClose(m *Status) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cLITransferConfigFileServer) Recv() (*File, error) {
	m := new(File)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CLI_ReadConfigFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CLIServer).ReadConfigFile(m, &cLIReadConfigFileServer{stream})
}

type CLI_ReadConfigFileServer interface {
	Send(*File) error
	grpc.ServerStream
}

type cLIReadConfigFileServer struct {
	grpc.ServerStream
}

func (x *cLIReadConfigFileServer) Send(m *File) error {
	return x.ServerStream.SendMsg(m)
}

func _CLI_ListConfigurations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CLIServer).ListConfigurations(m, &cLIListConfigurationsServer{stream})
}

type CLI_ListConfigurationsServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type cLIListConfigurationsServer struct {
	grpc.ServerStream
}

func (x *cLIListConfigurationsServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _CLI_RemoveConfigFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).RemoveConfigFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/RemoveConfigFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).RemoveConfigFile(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_StartListeningFromCsv_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CLIServer).StartListeningFromCsv(&cLIStartListeningFromCsvServer{stream})
}

type CLI_StartListeningFromCsvServer interface {
	SendAndClose(*Job) error
	Recv() (*RunConfiguration, error)
	grpc.ServerStream
}

type cLIStartListeningFromCsvServer struct {
	grpc.ServerStream
}

func (x *cLIStartListeningFromCsvServer) SendAndClose(m *Job) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cLIStartListeningFromCsvServer) Recv() (*RunConfiguration, error) {
	m := new(RunConfiguration)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CLI_StartListeningSlave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).StartListeningSlave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/StartListeningSlave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).StartListeningSlave(ctx, req.(*RunConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_ViewAllRunningJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CLIServer).ViewAllRunningJobs(m, &cLIViewAllRunningJobsServer{stream})
}

type CLI_ViewAllRunningJobsServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type cLIViewAllRunningJobsServer struct {
	grpc.ServerStream
}

func (x *cLIViewAllRunningJobsServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _CLI_StopListeningJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Job)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).StopListeningJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/StopListeningJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).StopListeningJob(ctx, req.(*Job))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_StopAllRunningJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).StopAllRunningJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/StopAllRunningJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).StopAllRunningJobs(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_ListOutputKeysForHost_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Slave)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CLIServer).ListOutputKeysForHost(m, &cLIListOutputKeysForHostServer{stream})
}

type CLI_ListOutputKeysForHostServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type cLIListOutputKeysForHostServer struct {
	grpc.ServerStream
}

func (x *cLIListOutputKeysForHostServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _CLI_GetRawOutput_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OutputId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CLIServer).GetRawOutput(m, &cLIGetRawOutputServer{stream})
}

type CLI_GetRawOutputServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type cLIGetRawOutputServer struct {
	grpc.ServerStream
}

func (x *cLIGetRawOutputServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _CLI_GetMatchedOutput_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OutputId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CLIServer).GetMatchedOutput(m, &cLIGetMatchedOutputServer{stream})
}

type CLI_GetMatchedOutputServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type cLIGetMatchedOutputServer struct {
	grpc.ServerStream
}

func (x *cLIGetMatchedOutputServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _CLI_DeleteOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutputId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).DeleteOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/DeleteOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).DeleteOutput(ctx, req.(*OutputId))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_DeleteOutputWithGivenTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutputId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).DeleteOutputWithGivenTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/DeleteOutputWithGivenTimestamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).DeleteOutputWithGivenTimestamp(ctx, req.(*OutputId))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_DeleteAllOutputOfHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Slave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).DeleteAllOutputOfHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/DeleteAllOutputOfHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).DeleteAllOutputOfHost(ctx, req.(*Slave))
	}
	return interceptor(ctx, in, info, handler)
}

var _CLI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "CLI",
	HandlerType: (*CLIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddSlave",
			Handler:    _CLI_AddSlave_Handler,
		},
		{
			MethodName: "DeleteSlave",
			Handler:    _CLI_DeleteSlave_Handler,
		},
		{
			MethodName: "DeleteSlaves",
			Handler:    _CLI_DeleteSlaves_Handler,
		},
		{
			MethodName: "RemoveConfigFile",
			Handler:    _CLI_RemoveConfigFile_Handler,
		},
		{
			MethodName: "StartListeningSlave",
			Handler:    _CLI_StartListeningSlave_Handler,
		},
		{
			MethodName: "StopListeningJob",
			Handler:    _CLI_StopListeningJob_Handler,
		},
		{
			MethodName: "StopAllRunningJobs",
			Handler:    _CLI_StopAllRunningJobs_Handler,
		},
		{
			MethodName: "DeleteOutput",
			Handler:    _CLI_DeleteOutput_Handler,
		},
		{
			MethodName: "DeleteOutputWithGivenTimestamp",
			Handler:    _CLI_DeleteOutputWithGivenTimestamp_Handler,
		},
		{
			MethodName: "DeleteAllOutputOfHost",
			Handler:    _CLI_DeleteAllOutputOfHost_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListSlaves",
			Handler:       _CLI_ListSlaves_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TransferConfigFile",
			Handler:       _CLI_TransferConfigFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadConfigFile",
			Handler:       _CLI_ReadConfigFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListConfigurations",
			Handler:       _CLI_ListConfigurations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StartListeningFromCsv",
			Handler:       _CLI_StartListeningFromCsv_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ViewAllRunningJobs",
			Handler:       _CLI_ViewAllRunningJobs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListOutputKeysForHost",
			Handler:       _CLI_ListOutputKeysForHost_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetRawOutput",
			Handler:       _CLI_GetRawOutput_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetMatchedOutput",
			Handler:       _CLI_GetMatchedOutput_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rpc.proto",
}
