// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rpc.proto

package rpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Slave struct {
	Username             string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Host                 string   `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Slave) Reset()         { *m = Slave{} }
func (m *Slave) String() string { return proto.CompactTextString(m) }
func (*Slave) ProtoMessage()    {}
func (*Slave) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{0}
}

func (m *Slave) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Slave.Unmarshal(m, b)
}
func (m *Slave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Slave.Marshal(b, m, deterministic)
}
func (m *Slave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slave.Merge(m, src)
}
func (m *Slave) XXX_Size() int {
	return xxx_messageInfo_Slave.Size(m)
}
func (m *Slave) XXX_DiscardUnknown() {
	xxx_messageInfo_Slave.DiscardUnknown(m)
}

var xxx_messageInfo_Slave proto.InternalMessageInfo

func (m *Slave) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Slave) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Slave) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type Status struct {
	Status               bool     `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{1}
}

func (m *Status) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Status.Unmarshal(m, b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Status.Marshal(b, m, deterministic)
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return xxx_messageInfo_Status.Size(m)
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type Chunk struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Chunk) Reset()         { *m = Chunk{} }
func (m *Chunk) String() string { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()    {}
func (*Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{2}
}

func (m *Chunk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Chunk.Unmarshal(m, b)
}
func (m *Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Chunk.Marshal(b, m, deterministic)
}
func (m *Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chunk.Merge(m, src)
}
func (m *Chunk) XXX_Size() int {
	return xxx_messageInfo_Chunk.Size(m)
}
func (m *Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_Chunk proto.InternalMessageInfo

func (m *Chunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{3}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Message struct {
	Text                 string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{4}
}

func (m *Message) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Message.Unmarshal(m, b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Message.Marshal(b, m, deterministic)
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return xxx_messageInfo_Message.Size(m)
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func init() {
	proto.RegisterType((*Slave)(nil), "Slave")
	proto.RegisterType((*Status)(nil), "Status")
	proto.RegisterType((*Chunk)(nil), "Chunk")
	proto.RegisterType((*Empty)(nil), "Empty")
	proto.RegisterType((*Message)(nil), "Message")
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor_77a6da22d6a3feb1) }

var fileDescriptor_77a6da22d6a3feb1 = []byte{
	// 291 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x91, 0xc1, 0x4e, 0x83, 0x40,
	0x10, 0x86, 0x43, 0x6b, 0x69, 0x3b, 0xd6, 0xcb, 0x46, 0x4d, 0xd3, 0x46, 0x25, 0x5c, 0xe4, 0x44,
	0x8c, 0x3e, 0x81, 0x41, 0x4d, 0x4c, 0xea, 0x85, 0xf5, 0x05, 0x56, 0x99, 0x52, 0x22, 0xdd, 0x25,
	0xbb, 0x43, 0xd5, 0xc7, 0xf1, 0x4d, 0x0d, 0x53, 0x44, 0x8d, 0x1a, 0x4f, 0xfc, 0x33, 0xf3, 0xf1,
	0xcf, 0xfc, 0x59, 0x18, 0xdb, 0xea, 0x31, 0xae, 0xac, 0x21, 0x13, 0x4a, 0x18, 0xc8, 0x52, 0x6d,
	0x50, 0xcc, 0x60, 0x54, 0x3b, 0xb4, 0x5a, 0xad, 0x71, 0xea, 0x05, 0x5e, 0x34, 0x4e, 0xbb, 0x5a,
	0x08, 0xd8, 0x59, 0x19, 0x47, 0xd3, 0x1e, 0xf7, 0x59, 0x37, 0x7c, 0xa5, 0x9c, 0x7b, 0x36, 0x36,
	0x9b, 0xf6, 0xb7, 0xfc, 0x47, 0x1d, 0x06, 0xe0, 0x4b, 0x52, 0x54, 0x3b, 0x71, 0x08, 0xbe, 0x63,
	0xc5, 0x9e, 0xa3, 0xb4, 0xad, 0xc2, 0x39, 0x0c, 0x92, 0x55, 0xad, 0x9f, 0x1a, 0xeb, 0x4c, 0x91,
	0xe2, 0xf1, 0x24, 0x65, 0x1d, 0x0e, 0x61, 0x70, 0xbd, 0xae, 0xe8, 0x35, 0x3c, 0x82, 0xe1, 0x1d,
	0x3a, 0xa7, 0x72, 0x3e, 0x81, 0xf0, 0x85, 0xda, 0xd3, 0x58, 0x9f, 0xbf, 0xf5, 0xa0, 0x9f, 0x2c,
	0x6e, 0xc5, 0x1c, 0x46, 0x97, 0x59, 0xb6, 0x8d, 0xe1, 0xc7, 0xfc, 0x9d, 0x0d, 0xe3, 0xf6, 0x82,
	0x63, 0xd8, 0xbd, 0xc2, 0x12, 0x09, 0xff, 0x9c, 0xc3, 0xa2, 0x70, 0xc4, 0x5d, 0x27, 0xfc, 0x98,
	0x37, 0xcf, 0x5a, 0xec, 0xcc, 0x13, 0x27, 0x30, 0xf9, 0xf2, 0xff, 0x27, 0xd1, 0x19, 0x9c, 0x82,
	0xb8, 0xb7, 0x4a, 0xbb, 0x25, 0xda, 0xc4, 0xe8, 0x65, 0x91, 0xdf, 0x14, 0x65, 0xb3, 0x87, 0xf3,
	0x75, 0x58, 0xe4, 0x89, 0x08, 0x0e, 0x24, 0x29, 0x4b, 0xcd, 0x3a, 0xd4, 0x85, 0xce, 0x25, 0xda,
	0x0d, 0xda, 0x5f, 0x2d, 0xf7, 0x25, 0x99, 0xea, 0x7f, 0x30, 0x80, 0xbd, 0x6f, 0xe0, 0x8f, 0x78,
	0x0f, 0x3e, 0x3f, 0xf3, 0xc5, 0x7b, 0x00, 0x00, 0x00, 0xff, 0xff, 0x42, 0xfe, 0xd1, 0x77, 0xf3,
	0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CLIClient is the client API for CLI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CLIClient interface {
	//    These methods are used to add & delete slaves on server.
	AddSlave(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error)
	DeleteSlave(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error)
	ListSlaves(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ListSlavesClient, error)
	DeleteSlaves(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	//    These method is used to Transfer files.
	TransferConfigFile(ctx context.Context, opts ...grpc.CallOption) (CLI_TransferConfigFileClient, error)
	//    These method is used to start the listening process.
	//    TODO
	StartListeningServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	StopListeningServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error)
	StopListening(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error)
}

type cLIClient struct {
	cc *grpc.ClientConn
}

func NewCLIClient(cc *grpc.ClientConn) CLIClient {
	return &cLIClient{cc}
}

func (c *cLIClient) AddSlave(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/AddSlave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) DeleteSlave(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/DeleteSlave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) ListSlaves(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CLI_ListSlavesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[0], "/CLI/ListSlaves", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLIListSlavesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CLI_ListSlavesClient interface {
	Recv() (*Slave, error)
	grpc.ClientStream
}

type cLIListSlavesClient struct {
	grpc.ClientStream
}

func (x *cLIListSlavesClient) Recv() (*Slave, error) {
	m := new(Slave)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) DeleteSlaves(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/DeleteSlaves", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) TransferConfigFile(ctx context.Context, opts ...grpc.CallOption) (CLI_TransferConfigFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CLI_serviceDesc.Streams[1], "/CLI/TransferConfigFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &cLITransferConfigFileClient{stream}
	return x, nil
}

type CLI_TransferConfigFileClient interface {
	Send(*Chunk) error
	CloseAndRecv() (*Status, error)
	grpc.ClientStream
}

type cLITransferConfigFileClient struct {
	grpc.ClientStream
}

func (x *cLITransferConfigFileClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cLITransferConfigFileClient) CloseAndRecv() (*Status, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Status)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cLIClient) StartListeningServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/StartListeningServers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) StopListeningServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/StopListeningServers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLIClient) StopListening(ctx context.Context, in *Slave, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/CLI/StopListening", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CLIServer is the server API for CLI service.
type CLIServer interface {
	//    These methods are used to add & delete slaves on server.
	AddSlave(context.Context, *Slave) (*Status, error)
	DeleteSlave(context.Context, *Slave) (*Status, error)
	ListSlaves(*Empty, CLI_ListSlavesServer) error
	DeleteSlaves(context.Context, *Empty) (*Status, error)
	//    These method is used to Transfer files.
	TransferConfigFile(CLI_TransferConfigFileServer) error
	//    These method is used to start the listening process.
	//    TODO
	StartListeningServers(context.Context, *Empty) (*Status, error)
	StopListeningServers(context.Context, *Empty) (*Status, error)
	StopListening(context.Context, *Slave) (*Status, error)
}

// UnimplementedCLIServer can be embedded to have forward compatible implementations.
type UnimplementedCLIServer struct {
}

func (*UnimplementedCLIServer) AddSlave(ctx context.Context, req *Slave) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSlave not implemented")
}
func (*UnimplementedCLIServer) DeleteSlave(ctx context.Context, req *Slave) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSlave not implemented")
}
func (*UnimplementedCLIServer) ListSlaves(req *Empty, srv CLI_ListSlavesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListSlaves not implemented")
}
func (*UnimplementedCLIServer) DeleteSlaves(ctx context.Context, req *Empty) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSlaves not implemented")
}
func (*UnimplementedCLIServer) TransferConfigFile(srv CLI_TransferConfigFileServer) error {
	return status.Errorf(codes.Unimplemented, "method TransferConfigFile not implemented")
}
func (*UnimplementedCLIServer) StartListeningServers(ctx context.Context, req *Empty) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartListeningServers not implemented")
}
func (*UnimplementedCLIServer) StopListeningServers(ctx context.Context, req *Empty) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopListeningServers not implemented")
}
func (*UnimplementedCLIServer) StopListening(ctx context.Context, req *Slave) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopListening not implemented")
}

func RegisterCLIServer(s *grpc.Server, srv CLIServer) {
	s.RegisterService(&_CLI_serviceDesc, srv)
}

func _CLI_AddSlave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Slave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).AddSlave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/AddSlave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).AddSlave(ctx, req.(*Slave))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_DeleteSlave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Slave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).DeleteSlave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/DeleteSlave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).DeleteSlave(ctx, req.(*Slave))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_ListSlaves_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CLIServer).ListSlaves(m, &cLIListSlavesServer{stream})
}

type CLI_ListSlavesServer interface {
	Send(*Slave) error
	grpc.ServerStream
}

type cLIListSlavesServer struct {
	grpc.ServerStream
}

func (x *cLIListSlavesServer) Send(m *Slave) error {
	return x.ServerStream.SendMsg(m)
}

func _CLI_DeleteSlaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).DeleteSlaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/DeleteSlaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).DeleteSlaves(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_TransferConfigFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CLIServer).TransferConfigFile(&cLITransferConfigFileServer{stream})
}

type CLI_TransferConfigFileServer interface {
	SendAndClose(*Status) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type cLITransferConfigFileServer struct {
	grpc.ServerStream
}

func (x *cLITransferConfigFileServer) SendAndClose(m *Status) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cLITransferConfigFileServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CLI_StartListeningServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).StartListeningServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/StartListeningServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).StartListeningServers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_StopListeningServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).StopListeningServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/StopListeningServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).StopListeningServers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLI_StopListening_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Slave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLIServer).StopListening(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CLI/StopListening",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLIServer).StopListening(ctx, req.(*Slave))
	}
	return interceptor(ctx, in, info, handler)
}

var _CLI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "CLI",
	HandlerType: (*CLIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddSlave",
			Handler:    _CLI_AddSlave_Handler,
		},
		{
			MethodName: "DeleteSlave",
			Handler:    _CLI_DeleteSlave_Handler,
		},
		{
			MethodName: "DeleteSlaves",
			Handler:    _CLI_DeleteSlaves_Handler,
		},
		{
			MethodName: "StartListeningServers",
			Handler:    _CLI_StartListeningServers_Handler,
		},
		{
			MethodName: "StopListeningServers",
			Handler:    _CLI_StopListeningServers_Handler,
		},
		{
			MethodName: "StopListening",
			Handler:    _CLI_StopListening_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListSlaves",
			Handler:       _CLI_ListSlaves_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TransferConfigFile",
			Handler:       _CLI_TransferConfigFile_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "rpc.proto",
}
